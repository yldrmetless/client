"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(require("react"));
var glider_js_1 = __importDefault(require("glider-js"));
var makeGliderOptions = function (_a) {
    var arrows = _a.arrows, hasArrows = _a.hasArrows, dots = _a.dots, hasDots = _a.hasDots, nextButtonEl = _a.nextButtonEl, prevButtonEl = _a.prevButtonEl, dotsEl = _a.dotsEl, restProps = __rest(_a, ["arrows", "hasArrows", "dots", "hasDots", "nextButtonEl", "prevButtonEl", "dotsEl"]);
    return (__assign(__assign({}, restProps), { skipTrack: true, arrows: (hasArrows && {
            next: (arrows && arrows.next) || nextButtonEl,
            prev: (arrows && arrows.prev) || prevButtonEl,
        }) ||
            undefined, dots: (hasDots && dots) || dotsEl || undefined }));
};
var GliderComponent = React.forwardRef(function (props, ref) {
    var id = props.id, containerElement = props.containerElement, className = props.className, hasArrows = props.hasArrows, arrows = props.arrows, hasDots = props.hasDots, dots = props.dots, scrollToSlide = props.scrollToSlide, scrollToPage = props.scrollToPage, iconLeft = props.iconLeft, iconRight = props.iconRight, skipTrack = props.skipTrack, children = props.children, onLoad = props.onLoad, onSlideVisible = props.onSlideVisible, onAnimated = props.onAnimated, onRemove = props.onRemove, onRefresh = props.onRefresh, onAdd = props.onAdd, onDestroy = props.onDestroy, onSlideHidden = props.onSlideHidden, restProps = __rest(props, ["id", "containerElement", "className", "hasArrows", "arrows", "hasDots", "dots", "scrollToSlide", "scrollToPage", "iconLeft", "iconRight", "skipTrack", "children", "onLoad", "onSlideVisible", "onAnimated", "onRemove", "onRefresh", "onAdd", "onDestroy", "onSlideHidden"]);
    var autoId = React.useId();
    var prevButtonRef = React.useRef(null);
    var nextButtonRef = React.useRef(null);
    var dotsRef = React.useRef(null);
    var elementRef = React.useRef(null);
    var gliderRef = React.useRef(null);
    // initialize the glider
    var callbackRef = React.useCallback(function (element) {
        elementRef.current = element;
        if (element && !gliderRef.current) {
            var glider = new glider_js_1.default(element, makeGliderOptions(__assign(__assign({}, restProps), { arrows: arrows, hasArrows: hasArrows, dots: dots, hasDots: hasDots, nextButtonEl: nextButtonRef.current, prevButtonEl: prevButtonRef.current, dotsEl: dotsRef.current })));
            gliderRef.current = glider;
            if (onLoad) {
                onLoad.call(glider, new CustomEvent("glider-loaded", {
                    detail: { target: element },
                }));
            }
            if (scrollToSlide) {
                glider.scrollItem(scrollToSlide - 1);
            }
            else if (scrollToPage) {
                glider.scrollItem(scrollToPage - 1, true);
            }
            // bind event listeners
            var addEventListener_1 = function (event, fn) {
                if (typeof fn === "function") {
                    element.addEventListener(event, fn);
                }
            };
            addEventListener_1("glider-slide-visible", onSlideVisible);
            addEventListener_1("glider-animated", onAnimated);
            addEventListener_1("glider-remove", onRemove);
            addEventListener_1("glider-refresh", onRefresh);
            addEventListener_1("glider-add", onAdd);
            addEventListener_1("glider-destroy", onDestroy);
            addEventListener_1("glider-slide-hidden", onSlideHidden);
        }
    }, [
        arrows,
        dots,
        hasArrows,
        hasDots,
        onLoad,
        restProps,
        scrollToPage,
        scrollToSlide,
        onAdd,
        onAnimated,
        onDestroy,
        onRefresh,
        onRemove,
        onSlideHidden,
        onSlideVisible,
    ]);
    // when the props update, sync the glider
    React.useEffect(function () {
        if (gliderRef.current) {
            gliderRef.current.setOption(makeGliderOptions(__assign(__assign({}, restProps), { arrows: arrows, hasArrows: hasArrows, dots: dots, hasDots: hasDots, nextButtonEl: nextButtonRef.current, prevButtonEl: prevButtonRef.current, dotsEl: dotsRef.current })), true);
            gliderRef.current.refresh(true);
        }
    }, [arrows, dots, hasArrows, hasDots, restProps]);
    // when the event listeners change, sync the glider
    React.useEffect(function () {
        if (elementRef.current) {
            var addEventListener_2 = function (event, fn) {
                var _a;
                if (typeof fn === "function") {
                    (_a = elementRef.current) === null || _a === void 0 ? void 0 : _a.addEventListener(event, fn);
                }
            };
            addEventListener_2("glider-slide-visible", onSlideVisible);
            addEventListener_2("glider-animated", onAnimated);
            addEventListener_2("glider-remove", onRemove);
            addEventListener_2("glider-refresh", onRefresh);
            addEventListener_2("glider-add", onAdd);
            addEventListener_2("glider-destroy", onDestroy);
            addEventListener_2("glider-slide-hidden", onSlideHidden);
        }
        return function () {
            var removeEventListener = function (event, fn) {
                var _a;
                if (typeof fn === "function") {
                    (_a = elementRef.current) === null || _a === void 0 ? void 0 : _a.removeEventListener(event, fn);
                }
            };
            removeEventListener("glider-slide-visible", onSlideVisible);
            removeEventListener("glider-animated", onAnimated);
            removeEventListener("glider-remove", onRemove);
            removeEventListener("glider-refresh", onRefresh);
            removeEventListener("glider-add", onAdd);
            removeEventListener("glider-destroy", onDestroy);
            removeEventListener("glider-slide-hidden", onSlideHidden);
        };
    }, [
        onAdd,
        onAnimated,
        onDestroy,
        onRefresh,
        onRemove,
        onSlideHidden,
        onSlideVisible,
    ]);
    // expose the glider instance to the user so they can call the methods too
    React.useImperativeHandle(ref, function () { return gliderRef.current; });
    var Element = containerElement || "div";
    return (React.createElement(Element, { className: "glider-contain" },
        props.hasArrows && !arrows && (React.createElement("button", { type: "button", className: "glider-prev", "aria-label": "Previous", ref: prevButtonRef }, iconLeft || "«")),
        React.createElement("div", { id: id || autoId, className: className, ref: callbackRef }, skipTrack ? children : React.createElement("div", null, children)),
        hasDots && !dots && React.createElement("div", { ref: dotsRef }),
        props.hasArrows && !arrows && (React.createElement("button", { type: "button", className: "glider-next", "aria-label": "Next", ref: nextButtonRef }, iconRight || "»"))));
});
exports.default = GliderComponent;
//# sourceMappingURL=index.js.map